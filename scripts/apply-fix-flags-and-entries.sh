#!/usr/bin/env bash
set -euo pipefail

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Sumo – Apply Flags & Entries Delta v0.3.1"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

here="$(pwd)"
ts_state_dir="src/state"
flags_file="$ts_state_dir/flags.ts"
static_idx="static/index.html"
legacy_static="static/index.legacy.html"
vite_cfg="vite.config.ts"

# Ensure src/state exists
mkdir -p "$ts_state_dir"

# Backup & move static/index.html if present to avoid Vite scanning two entries
if [[ -f "$static_idx" ]]; then
  echo "→ Detected $static_idx — moving to $legacy_static to avoid dual HTML entries."
  if [[ -f "$legacy_static" ]]; then
    ts="$(date +%s)"
    mv "$static_idx" "static/index.${ts}.legacy.html"
    echo "  • Moved to static/index.${ts}.legacy.html"
  else
    mv "$static_idx" "$legacy_static"
    echo "  • Moved to $legacy_static"
  fi
else
  echo "→ No static/index.html present — OK."
fi

# Install/replace flags.ts with an implementation that exports a named `flags`
echo "→ Writing $flags_file ..."
cat > "$flags_file" <<'TS'
// Auto-generated by apply-fix-flags-and-entries.sh
// Provides a named export `flags` expected by App.tsx
// and simple helpers with localStorage persistence.

export type FeatureFlag = 'training' | 'shop' | 'tournament' | 'stats' | 'matchViewer'

const DEFAULTS: Record<FeatureFlag, boolean> = {
  training: true,
  shop: true,
  tournament: true,
  stats: true,
  matchViewer: true,
}

const STORAGE_KEY = 'sumo.flags.v1'

function load(): Record<FeatureFlag, boolean> {
  if (typeof localStorage === 'undefined') return { ...DEFAULTS }
  try {
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) return { ...DEFAULTS }
    const parsed = JSON.parse(raw)
    return { ...DEFAULTS, ...parsed }
  } catch {
    return { ...DEFAULTS }
  }
}

function save(next: Record<FeatureFlag, boolean>) {
  try {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(next))
    }
  } catch {}
}

let cache = load()

// Named export expected by: import { flags } from '@state/flags'
export const flags: Record<FeatureFlag, boolean> = new Proxy(cache as any, {
  set(_t, prop: string, value) {
    if (prop in cache) {
      // @ts-ignore
      cache[prop as FeatureFlag] = !!value
      save(cache)
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('flags:change', { detail: { ...cache } }))
      }
      return true
    }
    return false
  },
  get(_t, prop: string) {
    // @ts-ignore
    return cache[prop]
  },
})

export function getFlags() { return { ...cache } }
export function setFlag(k: FeatureFlag, val: boolean) { (flags as any)[k] = !!val }
export function toggleFlag(k: FeatureFlag) { setFlag(k, !cache[k]) }
export function resetFlags() { cache = { ...DEFAULTS }; save(cache) }
TS

echo "  • flags.ts written"

# Ensure @state alias exists in vite.config.ts
if [[ -f "$vite_cfg" ]]; then
  if grep -q "@state" "$vite_cfg"; then
    echo "→ @state alias already present in $vite_cfg — OK."
  else
    echo "→ Patching $vite_cfg to add @state alias..."
    cp "$vite_cfg" "${vite_cfg}.bak_flags_$(date +%s)"
    # Insert alias safely: if resolve exists, add to alias; otherwise create resolve block
    if grep -q "resolve:\s*{" "$vite_cfg"; then
      # Add alias entry into existing resolve.alias array or object
      # Try to find alias:[ ... ] first
      if grep -q "alias:\s*\[" "$vite_cfg"; then
        # Append to array (naive but safe): insert before the closing ]
        perl -0777 -i -pe "s/alias:\s*\[(.*?)\]/'alias:['.\$1.(\$1=~/\S/ ? ', ' : '') ."{ find: '@state', replacement: '\${here//\//\/}\/src\/state' }".']'/s" "$vite_cfg"
      else
        # Object style: alias: { ... }
        perl -0777 -i -pe "s/alias:\s*\{(.*?)\}/'alias:{'.\$1.(\$1=~/\S/ ? ', ' : '') ."'@state': '\${here//\//\/}\/src\/state'".'}'/s" "$vite_cfg"
      fi
    else
      # No resolve block — add one near top-level defineConfig
      perl -0777 -i -pe "s/defineConfig\(\{/'defineConfig({\n  resolve: { alias: { \'@state\': \'\${here//\//\/}\/src\/state\' } },\n'/s" "$vite_cfg"
    fi
    echo "  • Patched alias @state -> $here/src/state"
  fi
else
  echo "⚠️  $vite_cfg not found — alias step skipped."
fi

# Clean Vite caches to avoid stale dependency scans
rm -rf node_modules/.vite node_modules/.cache 2>/dev/null || true
echo "→ Cleaned Vite caches"

cat <<'DONE'

✅ Done.

Next:
  npm run dev

If you still see the 'entries' scan issue, it usually means another HTML
file is being treated as an entry by your Vite config or plugins. With
this script we moved static/index.html aside, which generally resolves it.
DONE
